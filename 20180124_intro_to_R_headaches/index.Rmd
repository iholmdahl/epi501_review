---
title: "Hands-on intro to R and Some Modeling"
author: "Inga Holmdahl"
date: "2/1/2019"
output:
  xaringan::moon_reader:
    css: "slides_style.css"
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```

# Goals for today

1. Make sure everybody has `R`, RStudio, and `deSolve` installed and can run code

--

2. Go through discrete time models of population and headaches

--

3. Go through non-infectious ODE model of headaches

--

4. Go over headaches worsheet

---

class: center, middle, inverse
## Did anybody here have trouble installing R?

---

class: center, middle, inverse
## Can you run this command with no errors?

```{r eval=FALSE}
library(deSolve)
```
--
If not, make sure you ran `install.packages("deSolve")` first.

---

class: center, middle, inverse
## Do you have the headache.zip file from Canvas?

---
# `R` Tips

- In `RStudio` highlight the code you want to run in the source panel (upper left) and use **CMD+Enter** or **Ctrl+Enter** to run it in the console
    - This allows you to build on old models without deleting your code

--

- Comment (`#`) your code as you build models (or as Caroline builds them)
    - In a week you'll probably forget why you wrote something some way

--

- Drawing the model and/or writing the equations first helps
    - A lot

--

- You will always be given boilerplate code

--

- Use `?` to see the arguments for functions

--

- Use **ALT + -** to quickly make an assignment (<-)

-- 

- It'll be ok! We don't expect you to be `R` masters
---

# Discrete model of headaches

- Here is `headache_discrete.R` with comments removed: 
```{r eval=FALSE}
N_t <- 500      
P_t <- 0        
incidence <- 0.05 
recovery <- 0.9    

dat <- NULL
timesteps <- 1:100

for (t in timesteps){
    N_t1 <- N_t - round(incidence*N_t) + round(recovery*P_t) 
    P_t1 <- P_t + round(incidence*N_t) - round(recovery*P_t)
    dat <- rbind(dat, c(N_t1, P_t1)) 
    
    N_t <- N_t1 
    P_t <- P_t1 
}

matplot(dat, xlab="time", ylab="number of people", type="l", lty = 1)
legend("topright", col = 1:2, legend = c("no headache","headache"), lwd=1)


```

- What's happening in this code? Line-by-line.
- Examine the output stored in the variable ‘data’, and plot the results. Each row of the matrix should add to the population size. What does this imply about the dynamics of our population?
- What does it mean mathematically for the population to be at equilibrium with respect to headaches?
- What is the equilibrium prevalence of headaches in the population in this case? 
--
    - 27/473 = 0.057

---

- Verify that **prevalence at equilibrium** is equal to the **incidence x duration**
    - incidence = 0.05
    - duration = 1/0.9
    - 1/0.9*0.05 = 0.055
--
- Note: this approximation only works at low prevalence!

---
# Differential Equation model of headaches

- Here is `headache_ODE.R` with comments removed: 
``` {r eval=FALSE}

library(deSolve)

times <- seq(0, 5000, by = 1)
yinit <- c(no_headache = 0.95, headache = 0.05)
parameters <- c(incidence = 0.02, recovery = 0.05)

headache_model <- function(times, yinit, parameters) {
    with(as.list(c(yinit, parameters)), {
      
      dno_headache <- recovery*headache - incidence*no_headache 
      dheadache <- incidence*no_headache - recovery*headache
      
      comparts <- list(c(dno_headache, dheadache))
      
      return(comparts)
    })
}

result <- as.data.frame(ode(y = yinit, times = times, 
                            func = headache_model, parms = parameters))

matplot(x = result[, "time"], y = result[, c("no_headache", "headache")], type = "l")
```

 - The solver needs your model written as a function that takes in a vector of times, initial values, and parameters 
 (in that order) and returns a list with derivatives of your compartments relative to time.

---

#

---
class: center, middle, inverse
# That's it.
## Thanks